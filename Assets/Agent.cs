using System;
using System.Collections;
using Assets.Planner;
using Unity.Mathematics;
using UnityEngine;
using Action = Assets.Planner.Action;

namespace Assets
{
    /// <summary>
    /// Drives an NPC character
    /// </summary>
    [RequireComponent(typeof(Rigidbody2D))]
    public class Agent : MonoBehaviour
    {
        #region Fields
        public Transform BulletPrefab;

        public Team Team;
        public float Health = 1;
        public float Armor = 1;
        public bool WeaponEquipped;
        #endregion

        #region GOAP variables
        /// <summary>
        /// Nearest enemy to whatever agent is running the planner, or null if no remaining enemies.
        /// </summary>
        public static Variable<Agent> NearestEnemy =
            new(
                nameof(NearestEnemy), 
                a => a.Nearest<Agent>(other => a.IsEnemy(other)));

        /// <summary>
        /// Distance from the agent running the planner to their nearest enemy
        /// </summary>
        public static Variable<float> RangeToEnemy =
            new(nameof(RangeToEnemy),
                a => a.DistanceTo(NearestEnemy.ValueFor(a)));

        /// <summary>
        /// True if the agent has line of sight to the nearest enemy
        /// </summary>
        public static Variable<bool> HaveLineOfSight = new(nameof(HaveLineOfSight),
            a => a.LineOfSightTo(NearestEnemy.ValueFor(a)));

        /// <summary>
        /// True if the agent has a weapon.
        /// Just a wrapper for the WeaponEquipped field
        /// </summary>
        public static Variable<bool> HaveWeapon = new(nameof(HaveWeapon), a => a.WeaponEquipped);

        /// <summary>
        /// Nearest unclaimed weapon to the agent, or null if none
        /// </summary>
        public static Variable<Weapon> NearestWeapon =
            new(
                nameof(NearestWeapon), 
                a => a.Nearest<Weapon>());

        /// <summary>
        /// True if there is a weapon of the field that can be grabbed
        /// </summary>
        public static Variable<bool> WeaponAvailable = new(nameof(WeaponAvailable), a => NearestWeapon.ValueFor(a) != null);
        #endregion

        #region GOAP goals
        /// <summary>
        /// True if the agent running the planner is close enough to the nearest enemy to punch them
        /// </summary>
        public static Goal InMeleeRange = 
            new Variable<bool>(nameof(InMeleeRange),
                   a => RangeToEnemy.ValueFor(a) < MeleeRange); 

        /// <summary>
        /// True if the agent running the planner has no remaining enemies
        /// </summary>
        public static Goal NoEnemies = NearestEnemy == null;

        /// <summary>
        /// Goals the agent's executive should try to enforce, in descending order of priority
        /// </summary>
        public static Goal[] TopLevelGoals = new[] { NoEnemies };
        #endregion
        
        #region GOAP actions
        /// <summary>
        /// Punch the NearestEnemy
        /// </summary>
        public static Action MeleeAttack = new Action(nameof(MeleeAttack), a => a.DoMeleeAttack())
                { Cost = 10 }
            .Achieves(NoEnemies)
            .Needs(InMeleeRange);

        /// <summary>
        /// Get within punching range to NearestEnemy
        /// </summary>
        public static Action CloseToMeleeRange = 
            new Action(nameof(CloseToMeleeRange),
                a => a.DoCloseToMeleeRange())
                .Achieves(InMeleeRange);

        /// <summary>
        /// Shoot NearestEnemy
        /// </summary>
        public static Action Shoot = new Action(nameof(Shoot), a => a.DoShoot())
            .Achieves(NoEnemies)
            .Needs(HaveWeapon);

        /// <summary>
        /// Grab NearestWeapon
        /// </summary>
        public static Action GetWeapon = new Action(nameof(GetWeapon), a => a.DoGetWeapon())
            .Achieves(HaveWeapon)
            .Needs(WeaponAvailable);
        #endregion

        #region Unity coroutines to implement (execute) GOAP actions generated by planner
        public static float MeleeRange = 4;
        public static float RunSpeed = 1;
        public static float RammingSpeed = 2;
        public static float BulletVelocity = 10;

        private IEnumerator DoCloseToMeleeRange()
        {
            // Cache target
            var target = NearestEnemy.ValueFor(this);
            while (target != null && DistanceTo(target) > MeleeRange)
            {
                MoveTo(target, RunSpeed);
                yield return null;
            }
            Stop();
        }

        private GameObject meleeTarget;
        private IEnumerator DoMeleeAttack()
        {
            // Cache target
            var target = NearestEnemy.ValueFor(this);

            //UnityEngine.Debug.Log($"{gameObject.name}: Start attack");
            while (target != null && DistanceTo(target)<MeleeRange/2)
            {
                MoveTo(target, -RunSpeed, true);
                yield return null;
            }
            if (target == null)
                yield break;

            //UnityEngine.Debug.Log($"{gameObject.name}: Separated");
            collided = false;
            meleeTarget = target.gameObject;
            // ReSharper disable once ConditionIsAlwaysTrueOrFalse
            while (target != null && !collided)
            {
                MoveTo(target, RammingSpeed);
                yield return null;
            }
            //UnityEngine.Debug.Log($"{gameObject.name}: MeleeAttack finished");
            meleeTarget = null;
            Stop();
        }

        private IEnumerator DoShoot()
        {
            if (!WeaponEquipped)
                yield break;
            Face(NearestEnemy.ValueFor(this));
            yield return new WaitForSeconds(.1f);
            var target = NearestEnemy.ValueFor(this);
            if (target == null || !LineOfSightTo(target))
                yield break;
            Fire();
            yield return new WaitForSeconds(.5f);
        }

        private void Fire()
        {
            var orb = Instantiate(BulletPrefab, transform.position + transform.right, Quaternion.identity);
            orb.GetComponent<Rigidbody2D>().velocity = transform.right * BulletVelocity;
        }

        private IEnumerator DoGetWeapon()
        {
            var target = NearestWeapon.ValueFor(this);
            while (target != null && DistanceTo(target) > .5f)
            {
                MoveTo(target, RunSpeed);
                yield return null;
            }

            if (target != null)
            {
                Destroy(target.gameObject);
                WeaponEquipped = true;
            }
        }
        #endregion

        #region Sensory methods
        private float DistanceTo(Component obj) => Vector2.Distance(transform.position, obj.transform.position);

        private T Nearest<T>(Func<T, bool> predicate = null) where T : Component
        {
            T closest = null;
            var distanceSq = float.PositiveInfinity;
            var position = rigidBody.position;
            foreach (var o in FindObjectsOfType<T>())
            {
                if (predicate != null && !predicate(o))
                    continue;
                var d = (position - (Vector2)o.transform.position).sqrMagnitude;
                if (d < distanceSq)
                {
                    distanceSq = d;
                    closest = o;
                }
            }
            return closest;
        }

        private bool LineOfSightTo(Component what)
        {
            if (what == null) return false;

            var position = transform.position;
            var offset = what.transform.position - position;
            var hits = Physics2D.RaycastAll(position, offset, offset.magnitude);
            if (hits == null || hits.Length != 2) return false;
            var hit = hits[1];
            return hit.collider != null && hit.collider.gameObject == what.gameObject;
        }

        private bool IsEnemy(Agent other) => Team != other.Team;
        #endregion

        #region Motion control primitives
        private void MoveTo(Component target, float speed, bool backup=false)
        {
            var offset = target.transform.position - transform.position;
            var velocity = offset * (speed / offset.magnitude);
            SetVelocity(velocity, velocity*(backup?-1:1));
        }
        
        public void SetVelocity(Vector2  velocity)
        {
            rigidBody.velocity = velocity;
            if (velocity != Vector2.zero)
                rigidBody.SetRotation(math.degrees(math.atan2(velocity.y, velocity.x)));
        }

        public void SetVelocity(Vector2  velocity, Vector2 facingDirection)
        {
            rigidBody.velocity = velocity;
            if (velocity != Vector2.zero)
                Face(facingDirection);
        }

        private void Face(Vector2 facingDirection)
        {
            rigidBody.SetRotation(math.degrees(math.atan2(facingDirection.y, facingDirection.x)));
            rigidBody.angularVelocity = 0;
        }

        private void Face(Component obj)
        {
            if (obj == null) return;
            Face(obj.transform.position - transform.position);
        }

        public void Stop()
        {
            SetVelocity(Vector2.zero);
            rigidBody.angularVelocity = 0;
        }
        #endregion

        #region Damage
        public void TakeDamage(float damage)
        {
            Health = math.max(Health - damage, 0);
            if (Health == 0)
                Die();
        }

        public void Die()
        {
            Stop();
            Destroy(gameObject);
        }
        #endregion

        #region Unity handlers
        public Color BaseColor =>  Team == Team.Blue ? Color.blue : Color.red;
        public Color BodyColor => (Health/2f + .5f) * BaseColor;

        private Rigidbody2D rigidBody;
        private SpriteRenderer spriteRenderer;

        /// <summary>
        /// Initialize rigidBody
        /// </summary>
        // ReSharper disable once UnusedMember.Local
        void Start()
        {
            rigidBody = GetComponent<Rigidbody2D>();
            spriteRenderer = GetComponent<SpriteRenderer>();
            StartCoroutine(Executive.ExecutiveCoroutine(this, TopLevelGoals));
        }

        // ReSharper disable once UnusedMember.Local
        private void Update() => spriteRenderer.color = BodyColor;

        private bool collided;
        // ReSharper disable once UnusedMember.Local
        private void OnCollisionEnter2D(Collision2D coll)
        {
            if (coll.otherRigidbody == null) return;
            var armor = Armor;
            if (coll.gameObject == meleeTarget)
                armor *= 10;
            var damage = CollisionMomentum(coll) / armor;
            TakeDamage(damage);
            collided = true;
        }

        private float CollisionMomentum(Collision2D coll)
        {
            var normal = coll.contacts[0].normal;
            return math.abs(Vector2.Dot(coll.relativeVelocity, normal) * coll.otherRigidbody.mass);
        }
        #endregion
    }
}
